<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>DooJjonKu: Dark Ritual</title>
    <style>
        * { touch-action: none; -webkit-user-select: none; user-select: none; box-sizing: border-box; font-family: 'Pretendard', sans-serif; }
        body { margin: 0; overflow: hidden; background: #050505; color: #eee; }
        canvas { display: block; }

        /* 클래스 선택 (디아블로 풍) */
        #class-select { position: fixed; inset: 0; background: radial-gradient(circle, #222, #000); z-index: 300; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        .class-row { display: flex; gap: 20px; margin-top: 30px; }
        .class-btn { width: 120px; padding: 20px 10px; background: #1a1a1a; border: 1px solid #444; color: #ccc; cursor: pointer; text-align: center; border-radius: 4px; }
        .class-btn:hover { border-color: #888; color: #fff; }
        .class-btn b { display: block; margin-bottom: 5px; color: #ffd700; }

        /* 게임 UI */
        #hud { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; align-items: flex-end; gap: 20px; pointer-events: none; }
        .orb { width: 80px; height: 80px; border-radius: 50%; border: 2px solid #444; position: relative; overflow: hidden; background: #111; }
        #hp-orb { background: radial-gradient(circle at bottom, #800, #200); }
        #mp-orb { background: radial-gradient(circle at bottom, #004, #001); }
        .fill { position: absolute; bottom: 0; width: 100%; transition: height 0.3s; }
        #hp-fill { height: 100%; background: #f00; opacity: 0.6; }
        #mp-fill { height: 0%; background: #44f; opacity: 0.6; }

        #joy-base { position: absolute; bottom: 40px; left: 40px; width: 100px; height: 100px; border: 1px solid #333; border-radius: 50%; }
        #joy-stick { position: absolute; top: 25px; left: 25px; width: 50px; height: 50px; background: rgba(255,255,255,0.1); border-radius: 50%; }
        #ult-btn { position: absolute; bottom: 45px; right: 45px; width: 85px; height: 85px; border: 2px solid #ffd700; border-radius: 50%; display: flex; align-items: center; justify-content: center; color: #ffd700; font-weight: bold; background: rgba(0,0,0,0.5); pointer-events: auto; }
    </style>
</head>
<body>

    <div id="class-select">
        <h1 style="letter-spacing: 5px; text-shadow: 0 0 20px red;">DOOJJONKU</h1>
        <div class="class-row">
            <div class="class-btn" onclick="start('barb')"><b>전사</b>휠윈드<br>피흡</div>
            <div class="class-btn" onclick="start('nec')"><b>강령술사</b>시체폭발<br>소환</div>
            <div class="class-btn" onclick="start('sha')"><b>주술사</b>체인라이트닝<br>토템</div>
        </div>
    </div>

    <div id="hud">
        <div class="orb" id="hp-orb"><div id="hp-fill" class="fill"></div></div>
        <div style="text-align:center;">
            <div id="lv-txt">LV. 1</div>
            <div id="kill-txt" style="font-size:12px; color:gold;">KILLS: 0</div>
        </div>
        <div class="orb" id="mp-orb"><div id="mp-fill" class="fill"></div></div>
    </div>

    <div id="joy-base"><div id="joy-stick"></div></div>
    <div id="ult-btn" onclick="useUlt()">SKILL</div>

    <canvas id="game"></canvas>

    <script>
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        let player, isLive = false, kills = 0, hp = 100, mp = 0, lv = 1, exp = 0;
        let enemies = [], bullets = [], particles = [], corpses = [], minions = [];
        let moveX = 0, moveY = 0, lastDir = 0, shake = 0;

        const classes = {
            barb: { name: 'Barbarian', color: '#ff4444', spd: 2.2, dmg: 3, type: 'melee' },
            nec: { name: 'Necro', color: '#99ff99', spd: 1.8, dmg: 1.5, type: 'summon' },
            sha: { name: 'Shaman', color: '#4444ff', spd: 1.9, dmg: 2, type: 'chain' }
        };

        function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
        window.addEventListener('resize', resize); resize();

        function start(c) {
            player = { ...classes[c], x: 0, y: 0, vx: 0, vy: 0 };
            document.getElementById('class-select').style.display = 'none';
            isLive = true; loop();
        }

        // --- 컨트롤 (부드러운 이동) ---
        const jBase = document.getElementById('joy-base');
        window.addEventListener('touchmove', (e) => {
            const t = e.touches[0];
            const r = jBase.getBoundingClientRect();
            const dx = t.clientX - (r.left + 50), dy = t.clientY - (r.top + 50);
            const dist = Math.min(Math.sqrt(dx*dx+dy*dy), 50);
            const ang = Math.atan2(dy, dx);
            if(dist > 5) {
                lastDir = ang;
                moveX = Math.cos(ang) * (dist/50);
                moveY = Math.sin(ang) * (dist/50);
                document.getElementById('joy-stick').style.transform = `translate(${Math.cos(ang)*dist}px, ${Math.sin(ang)*dist}px)`;
            }
        });
        window.addEventListener('touchend', () => { moveX = 0; moveY = 0; document.getElementById('joy-stick').style.transform = 'translate(0,0)'; });

        function useUlt() {
            if(mp < 100) return;
            mp = 0; shake = 15;
            if(player.type === 'nec') { // 시체 폭발
                corpses.forEach(c => {
                    spawnPart(c.x, c.y, 10, '#f0f');
                    enemies.forEach(e => {
                        if(Math.hypot(e.x-c.x, e.y-c.y) < 100) e.hp -= 10;
                    });
                });
                corpses = [];
            } else if(player.type === 'barb') { // 광폭화 휠윈드
                player.dmg *= 2; setTimeout(()=>player.dmg/=2, 3000);
            } else { // 토템 소환 (주변 적 정지)
                enemies.forEach(e => { if(Math.hypot(e.x-player.x, e.y-player.y)<200) e.spd = 0; });
                setTimeout(()=>enemies.forEach(e=>e.spd=0.5), 3000);
            }
        }

        function update() {
            if(!isLive) return;
            player.vx += (moveX * player.spd - player.vx) * 0.1;
            player.vy += (moveY * player.spd - player.vy) * 0.1;
            player.x += player.vx; player.y += player.vy;

            // 몹 스폰 및 AI
            if(enemies.length < 25 + lv*2) {
                const a = Math.random()*Math.PI*2;
                enemies.push({ x: player.x+Math.cos(a)*500, y: player.y+Math.sin(a)*500, hp: 3+lv, spd: 0.5 });
            }

            enemies.forEach((e, i) => {
                const ang = Math.atan2(player.y-e.y, player.x-e.x);
                e.x += Math.cos(ang)*e.spd; e.y += Math.sin(ang)*e.spd;

                // 공격 판정
                if(player.type === 'barb' && Math.hypot(player.x-e.x, player.y-e.y) < 40) {
                   if(Date.now()%10 < 2) { 
                       e.hp -= 0.1; 
                       if(Math.random()<0.05) hp = Math.min(100, hp+0.5); // 피흡
                   }
                }

                bullets.forEach((b, bi) => {
                    if(Math.hypot(b.x-e.x, b.y-e.y) < 20) {
                        e.hp -= player.dmg;
                        if(player.type === 'sha') { // 체인 라이트닝 전이
                            const next = enemies[i+1];
                            if(next) bullets.push({x: e.x, y: e.y, vx: (next.x-e.x)*0.1, vy: (next.y-e.y)*0.1, life: 1});
                        }
                        bullets.splice(bi, 1);
                    }
                });

                if(e.hp <= 0) {
                    corpses.push({x: e.x, y: e.y});
                    enemies.splice(i, 1); kills++; mp = Math.min(100, mp+5);
                    if(player.type === 'nec' && minions.length < 3) { // 해골 소환
                        minions.push({x: e.x, y: e.y, life: 500});
                    }
                }
                if(Math.hypot(player.x-e.x, player.y-e.y) < 15) hp -= 0.2;
            });

            // 소환수 AI
            minions.forEach((m, mi) => {
                const target = enemies[0];
                if(target) {
                    const a = Math.atan2(target.y-m.y, target.x-m.x);
                    m.x += Math.cos(a)*2; m.y += Math.sin(a)*2;
                    if(Math.hypot(target.x-m.x, target.y-m.y) < 20) target.hp -= 0.05;
                }
                m.life--; if(m.life <= 0) minions.splice(mi, 1);
            });

            // 자동 공격
            if(player.type !== 'barb' && Date.now() % 400 < 20) {
                bullets.push({x: player.x, y: player.y, vx: Math.cos(lastDir)*8, vy: Math.sin(lastDir)*8});
            }

            bullets.forEach((b, i) => { b.x += b.vx; b.y += b.vy; if(b.life) { b.life--; if(b.life<=0) bullets.splice(i,1); }});
            particles.forEach((p, i) => { p.x += p.vx; p.y += p.vy; p.life--; if(p.life<=0) particles.splice(i,1); });

            if(shake > 0) shake *= 0.9;
            document.getElementById('hp-fill').style.height = hp + "%";
            document.getElementById('mp-fill').style.height = mp + "%";
            document.getElementById('kill-txt').innerText = `KILLS: ${kills}`;
            if(hp <= 0) { alert("DEAD. KILLS: " + kills); location.reload(); }
        }

        function spawnPart(x, y, n, c) {
            for(let i=0; i<n; i++) particles.push({x, y, vx: (Math.random()-0.5)*10, vy: (Math.random()-0.5)*10, life: 20, color: c});
        }

        function draw() {
            ctx.save();
            ctx.translate((Math.random()-0.5)*shake, (Math.random()-0.5)*shake);
            ctx.fillStyle = '#050505'; ctx.fillRect(0,0,canvas.width, canvas.height);
            const cx = player.x - canvas.width/2, cy = player.y - canvas.height/2;

            // 시체 및 소환수
            corpses.forEach(c => { ctx.fillStyle = '#222'; ctx.fillRect(c.x-cx-4, c.y-cy-4, 8, 8); });
            minions.forEach(m => { ctx.fillStyle = '#eee'; ctx.fillRect(m.x-cx-5, m.y-cy-5, 10, 10); ctx.fillStyle='red'; ctx.fillRect(m.x-cx-2, m.y-cy-4, 4, 2); });

            enemies.forEach(e => { ctx.fillStyle = '#444'; ctx.fillRect(e.x-cx-8, e.y-cy-8, 16, 16); });
            bullets.forEach(b => { ctx.fillStyle = player.type==='sha'?'#0ff':'#fff'; ctx.beginPath(); ctx.arc(b.x-cx, b.y-cy, 3, 0, Math.PI*2); ctx.fill(); });
            
            // 플레이어 아우라
            if(player.type === 'barb') {
                ctx.strokeStyle = 'rgba(255,0,0,0.2)';
                ctx.beginPath(); ctx.arc(canvas.width/2, canvas.height/2, 40, 0, Math.PI*2); ctx.stroke();
            }

            ctx.fillStyle = player.color; ctx.fillRect(canvas.width/2-10, canvas.height/2-10, 20, 20);
            particles.forEach(p => { ctx.fillStyle = p.color; ctx.fillRect(p.x-cx, p.y-cy, 3, 3); });
            ctx.restore();
        }

        function loop() { update(); draw(); requestAnimationFrame(loop); }
    </script>
</body>
</html>
